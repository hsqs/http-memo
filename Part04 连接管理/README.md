# Part04 连接管理

### 4.1 TCP连接
&emsp;&emsp;几乎所有的HTTP通信都是由TCP/IP承载的，一旦建立一条TCP/IP连接，客户端和服务端之间的报文就永远不会丢失、受损、失序。

##### 4.1.2 TCP流是分段的、由IP分组传送
&emsp;&emsp;1、TCP的数据是通过IP分组来发送的。HTTP是“HTTP over TCP over IP”这个协议栈的最顶层，其安全版本HTTPS是在HTTP和TCP之间插入一个密码加密层（SSL）。  


&emsp;&emsp;2、HTTP要发送一条报文，以流的形式在一条打开的TCP连接上传输，TCP收到数据流，将数据流分成‘段’，并将‘段’封装在IP分组里，通过因特网传输。这些工作有TCP/IP软件完成，HTTP程序员什么都看不见啊。  

&emsp;&emsp;3、每个TCP段由IP分组承载，从一个IP地址发送到另一个IP地址，每个IP分组包括：  

 - 一个IP分组首部（通常20个字节）
 - 一个TCP段首部（通常20个字节）
 - 一个TCP数据库（0或多个字节）

&emsp;&emsp;4、IP首部包含了源和目的的IP地址、长度和其他一些标记。TCP首部包含了TCP的端口号、TCP控制标记，以及数据排序和完整性检测的一些数值。

##### 4.1.3 保持TCP连接持续不断的运行

&emsp;&emsp;1、任意时刻，计算机都有多条TCP连接，通过端口号区分这些连接，并可以同时处于打开状态。IP地址可以连接到正确的计算机，端口号连接到对应的应用程序上去。   


&emsp;&emsp;2、【源IP地址、源端口号、目的IP地址、目的端口号】4个值唯一的确定一条连接。

### 4.2 对TCP性能的考虑

&emsp;&emsp;1、HTTP紧挨着TCP，所以HTTP事务的性能很大程度上取决于底层TCP通道的性能。

##### 4.2.1 HTTP事务的时延
<center>![](./resource/4-7.png)</center>    
<center>串行HTTP事务的时间线</center>   

&emsp;&emsp;由上，HTTP 时延的主要原因有：

 1. 根据URL确定IP地址和端口。最差的情况下，可能持续数十秒。
 1. 向服务器发送TCP请求并等待应答。每条TCP连接都有建立时延。
 1. 建立了连接后，客户端通过TCP向服务端发送HTTP请求。Web服务器从TCP连接中读取报文并处理。因特网传输报文和处理报文需要时间。
 1. Web服务器回送HTTP响应，传输HTTP响应需要时间。

&emsp;&emsp;这些时延取决于硬件速度、网络和服务器负载、请求报文响应报文的大小，以及客户端与服务端之间的距离。TCP技术的复杂性也会对时延产生影响。  

##### 4.2.2 性能聚焦区域

 常见的TCP时延：

 1. TCP连接建立握手
 2. TCP慢启动拥塞控制
 3. 数据聚集的Nagle算法
 4. 用于捎带确认的TCP延迟算法
 5. TIME_WAIT时延和端口耗尽

##### 4.2.3 TCP连接的握手时延
&emsp;&emsp;1、在发送任意数据之前，TCP软件之间都会交换一系列的IP分组，对连接的参数进行沟通。**如果连接只是用来传递少量的数据，这些交换过程就会严重降低HTTP性能**

&emsp;&emsp;2、在发送数据之前，TCP要收发（从客户端开始）两个分组来建立连接。

&emsp;&emsp;TCP的3次握手：

 - 握手1. 客户端向服务端发送一个小的TCP分组（一般40~60字节），设置了特殊的SYN标记，说明这是一个连接请求。   
 - 握手2. 如果服务器接收了连接，就会对连接参数进行计算，并回送一个TCP分组，分组中SYN和ACK都被置位，说明请求已被接受。   
 - 握手3. 最后，客户端向服务端回送一条确认消息，通知连接已经成功建立。**现代的浏览器都允许客户端在这个确认分组中发送数据。**   

&emsp;&emsp;3、HTTP事务通常不会交换太多数据SYN/SYN+ACK产生一个可测量时延。   
&emsp;&emsp;4、TCP连接的ACK分组（握手的第三步）通常足够大，可以承载整个HTTP报文。   
&emsp;&emsp;5、最后，小的HTTP事务可能会在TCP建立连接上花费50%的时间或更多（小文件一次响应就发送完成）。   


##### 4.2.4 延迟确认

&emsp;&emsp;1、由于网络不能保证分组的传输（网络路由器超负荷会任意丢弃分组），所以TCP靠自己的确认机制来确保数据传输成功。   
&emsp;&emsp;2、 每个TCP段都有一个**序列号**和**校验和**，每个段的接收者会回送小的确认分组。如果发生者在指定时间内没有收到确认信息，发送者认为分组已破坏并重新发送。  
&emsp;&emsp;3、由于**确认报文很小**，所以TCP允许发往相同方向的输出数据分组中进行**捎带**。  
&emsp;&emsp;4、为了增加确认报文找到同向传输数据分组的可能性，很多TCP都实现了“延迟确认”算法。即在一个特定的时间窗口内（一般是100~200毫秒）将确认信息放在**缓冲区**，以寻找可以捎带它的分组，如果这段时间内没有这个方向的输出分组，就单独在分组中发送该确认。   
&emsp;&emsp;5、但是，HTTP具有双峰特征（发送和接收基本都是单向的发送数据）的请求 - 应答行为降低了捎带信息的可能。当希望向相反方向回传分组时，偏偏没有那么多可以用。此时，延迟确认算法反而会引入相当大的延时，可以根据不同操作系统来禁止或者调整延迟确认算法。

##### 4.2.5 TCP慢启动

&emsp;&emsp;1、TCP连接会随着时间自我调节。起初会限制连接速度，如果传输数据成功，会随着时间推移提高传输速度。这种调节称为**慢启动**，用于放置因特网的突然**过载和拥塞**。   
&emsp;&emsp;2、TCP慢启动限制了在任意时刻传输的分组数。在成功发送一个分组后，就有了发送两个分组的权限，如果下次的两个**都发**送成功，就可以发送四个分组，以此类推。这种方式叫打开拥塞窗口。   

##### 4.2.6 Nagle算法和TCP_NODELAY
&emsp;&emsp;1、TCP有一个数据流接口，应用程序可以将任意大小数据放入TCP栈中，即使以此放一个字节。但是，每个TCP段包含至少40字节的标记和首部，所以TCP发送**大量小分组**时，网络性能将急剧下降。（*发送大量单字节分组的行为称为“发送端傻窗口综合症”，这种行为效率很低，违反**社会道德**，甚至可能影响其他因特网流量*）。   
&emsp;&emsp;2、Nagle算法试图发送一个分组前，将大量TCP数据绑定在一起，，以提高利用率。但可能永远等不到额外数据填满一个分组而产生时延。另外还和延迟确认存在交互问题。  
&emsp;&emsp;3、HTTP通常会设置TCP_NODELAY来禁用Nagle算法。

##### 4.2.7 TIME_WAIT累积与端口耗尽

&emsp;&emsp;1、TIME_WAIT端口耗尽是非常严重的性能问题，但很少出现。   
&emsp;&emsp;2、某个TCP端关闭连接后，会在内存中维护一个小的控制块，记录最近关闭连接的IP地址和端口号。   
&emsp;&emsp;3、这个信息只会维持一小段时间（小于2分钟，以前网络很慢，网络中的分组在丢弃前可以存活1分钟左右，现在这个时间已经小得多），确保这段时间内不创建相同IP地址和端口号的连接。   
&emsp;&emsp;4、所以如果这个小的时间段内，有大量的连接出现，会将端口耗尽。   
&emsp;&emsp;5、为了避免这个问题，可以增加客户端负载生成机器的数量。或者服务端和客户端循环使用虚拟IP来增加可用连接数。   

























