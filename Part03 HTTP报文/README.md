# Part03 HTTP报文

### 3.1 报文流

##### 3.1.1 报文流入源端服务器
&emsp;&emsp;HTTP使用术语流入（inbound）和流出（outbound）来描述事物处理的方向。

##### 3.1.2 报文向下游流动
&emsp;&emsp;不管是是请求报文还是响应报文，所有报文都会向下游（downstream）流动，所有报文的发送者都在接收者的上游（upstream）。报文流方向不同，上下游的位置也是相对的。

### 3.2 报文组成部分
&emsp;&emsp;1、三部分：起始行（start line）、首部（header）、可选的主体（body）。  
&emsp;&emsp;2、起始行和首部是ASCII码文本，HTTP规定每行以\r\n（CRLF）作为结束标志，但稳健的程序也应该接受单个换行符作为行的终止。

##### 3.2.1 报文的语法

|部位|描述|
|---|---|
|方法（method）|客户端希望对资源执行的动作|
|请求URL（request-URL）|命名了所请求的资源|
|版本（version）|包括主要和次要版本，例如 HTTP/1.1|
|状态码（status-code）|描述请求过程中发生了什么|
|原因短语（reason-phrase）|原因短语只对人有意义|
|首部（header）|可以有0或多个首部，首部是键值对。首部以空行（CRLF）标志作为结束|
|实体的主体部分（entity-body）|主体可以是任意数据或空|

&emsp;&emsp;由于历史原因，在没有主体时，很多客户端和服务器都会省略首部后面的空白行，为了兼容，服务器和客户端都应该接受缺少空白行的报文。

##### 3.2.2 起始行
&emsp;&emsp;1、起始行的作用在于描述要做什么（what to do）和发生了什么（what happened）。  
&emsp;&emsp;2、请求行由方法+URL+HTTP版本，例如 GET /hello.html HTTP/1.1，所有字段以空格隔开。  
&emsp;&emsp;3、响应行由HTTP版本+数字状态码+原因短语，例如 HTTP/1.0 200 OK，所有字段以空格分隔。  
&emsp;&emsp;4、常用的HTTP方法：

|方法|描述|是否包含主体|
|---|---|---|
|GET|从服务器获取一份文档|否|
|HEAD|只从服务器获取文档首部|否|
|POST|向服务器发送要处理的数据|是|
|PUT|将请求的主体部分存储在服务器|是|
|TRACE|对可能经过代理服务器传送到服务器上去的报文进行追踪|否|
|OPTIONS|绝对可以在服务器上执行哪些方法|否|
|DELETE|从服务器上删除一份文档|否|

以上并不是HTTP的所有方法，除此之外，有些服务器会实现一些自己的请求方法，称为扩展方法。

&emsp;&emsp;5、状态码分类：

|整体范围|已定义范围|分类|
|---|---|---|
|100~199|100~101|信息提示|
|200~299|200~206|成功|
|300~399|300~305|重定向|
|400~499|400~415|客户端错误|
|500~599|500~505|服务器错误|
随着协议发展，可以接收到不在这个已定义范围内的状态码，可以根据其所处范围，视为其中普通一员来处理。

&emsp;&emsp;6、原因短语和状态码成对出现，原因短语本身无任何规定使用哪种形式。  
&emsp;&emsp;7、版本号不会被当做小数来处理，版本中的每个数字都会被当做单独的数字来处理。例如HTTP/2.22比HTTP/2.3高，因为22比3大。

##### 3.2.3 首部

&emsp;&emsp;1、起始行后面跟0或多个首部。  
&emsp;&emsp;2、首部分类：

|类型|描述|
|---|---|
|通用首部|既可以出现在请求报文和响应报文|
|请求首部|提供请求的信息|
|响应首部|提供响应的信息|
|实体首部|描述主体的长度和内容，或资源本身|
|扩展首部|规范中没有定义的首部|

&emsp;&emsp;3、过长的首部可以换行，但新的行要添加至少一个空格或制表符。例如：
```
server: test server head is 
   too long
```

##### 3.2.4 实体的主体部分

&emsp;&emsp;主体即为HTTP报文真正要传输的内容。

### 3.3 方法

##### 3.3.1 安全方法
&emsp;&emsp;GET和HEAD认为是安全的方法，但安全方法并不意味着什么动作都不执行，着取决于Web开发者。

##### 3.3.3 HEAD
&emsp;&emsp;HEAD 方法和GET很类似，但在响应中只返回首部，不返回实体。允许客户端在未获取资源情况下，预先得知资源的类型、响应码（是否成功）、是否被修改等。

##### 3.3.4 PUT
&emsp;&emsp;PUT让服务器用请求主体来创建一个所请求URL命名的新文档。如果已存在，则用新的替换。

##### 3.3.5 POST
&emsp;&emsp;通常用于支持HTML的表单。

##### 3.3.6 TRACE
&emsp;&emsp;TRACE请求会在目的服务器发送一个“环回”诊断，在行程最后一站的服务器会弹回一条TRACE响应，这样客户端就可以查看中间HTTP程序组成的请求响应链上，原始报文是否、以及何时被毁坏修改。TRACE响应的实体主体部分包含了响应服务器收到的请求的精确副本。

##### 3.3.7 OPTIONS
&emsp;&emsp;OPTIONS方法返回服务器支持的各种方法。

##### 3.3.9 扩展方法
&emsp;&emsp;对扩展方法应宽容处理，如果能在不破坏端到端行为的情况下，将带有未知方法的报文传递给下游服务器，代理就应该尝试传递这些报文。否则返回501 not Implemented。通常，都是对发送的内容严格一点，对接收的内容宽容一些来的策略来处理扩展方法。（严于律己，宽于律人，腻害了）。

### 3.4 状态码

##### 3.4.1 100~199--信息状态码
&emsp;&emsp;HTTP/1.1引入了信息状态码，由于信息状态码的复杂性和感知价值存在争论从而使用中受到限制。

|状态码|原因短语|含义|
|---|---|---|
|100|Continue|说明收到了请求的初始部分，请客户端继续|
|101|Switching Protocols|说明服务器正在根据客户端的指定，将协议转换成 Update 首部所列的协议|

&emsp;&emsp;客户端与100：  
&emsp;&emsp;1、如果客户端向服务器发送一个实体，并且愿意等待一个100的响应，那客户端就要向服务端发送一个携带100 Continue 的 Expect 请求首部，表示自己还要继续发送实体，否则应停止发送避免误导服务端。  
&emsp;&emsp;2、客户端只有在避免向服务端发送一个服务器无法处理的大实体时，才应该使用 100 Continue。  
&emsp;&emsp;3、如果客户端发送了有 100 Continue 的 Expect 首部，就不应该永远等待服务器发送 100 Continue 响应。超时后应该将实体发送出去。


&emsp;&emsp;服务端与100：  
&emsp;&emsp;1、服务器收到包含 100 Continue 的 Expect 首部时，会发送 100 Continue 响应或者一条错误状态码。服务器永远都不应该对没有发送包含 100 Continue 首部的客户端回送 100 Continue 响应。    
&emsp;&emsp;2、有可能在发送 100 响应之前收到了新的实体，表明客户端决定继续发送数据，此时服务端不再回送 100 状态码。
  
&emsp;&emsp;代理与100：  
&emsp;&emsp;1、代理收到一条包含 100 Continue 的 Expect 首部时，首先如果吓一跳确认支持HTTP/1.1(100是1.1引进的)或者并不知道下一跳的版本情况，就转发给下一跳，否则返回 417 Expectation Failed。